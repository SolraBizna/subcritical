<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
<head>
<title>SubCritical Lua developer documentation</title>
<meta http-equiv="Content-type" content="text/xhtml+xml; charset=utf-8" />
<link rel="stylesheet" type="text/css" href="css.css" />
</head>
<body>
<h1><tt>graphics</tt> package</h1>
<h2>License</h2>
<p>The <tt>graphics</tt> package is marked as <tt>Compatible</tt>, which means any game can use it.</p>
<h2>Classes</h2>
<h3 class="code"><a name="Frisket" />Frisket</h3>
<p>A <tt>Frisket</tt> is a pure alpha channel with no color information of its own. It is usually used for text. See <a href="#Drawable:BlitFrisket" class="code">Drawable:BlitFrisket</a>.</p>
<dl>
<dt class="code"><i>frisket</i> = SubCritical.Construct("Frisket", <i>width</i>, <i>height</i>)</dt>
<dd>Creates a new, completely transparent frisket.</dd>
<dt class="code"><a name="Frisket:CopyFrisket" /><i>destination</i>:CopyFrisket(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>)</dt>
<dd>Copies data from <i class="code">source</i> (a <a href="#Frisket" class="code">Frisket</a>) to <i class="code">destination</i>, with the top-left corner at <i class="code">x,y</i>. If <i class="code">source_*</i> are provided, deal with that subset of <i class="code">source</i>.</dd>
<dt class="code"><a name="Frisket:ModulateFrisket" /><i>destination</i>:ModulateFrisket(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>)</dt>
<dd>Multiplies the data from <i class="code">source</i> (a <a href="#Frisket" class="code">Frisket</a>) with the data already in <i class="code">destination</i>, with the top-left corner at <i class="code">x,y</i>. If <i class="code">source_*</i> are provided, deal with that subset of <i class="code">source</i>.</dd>
<dt class="code"><a name="Frisket:AddFrisket" /><i>destination</i>:AddFrisket(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>)</dt>
<dd>Adds the data from <i class="code">source</i> (a <a href="#Frisket" class="code">Frisket</a>) to the data already in <i class="code">destination</i>, with the top-left corner at <i class="code">x,y</i>. If <i class="code">source_*</i> are provided, deal with that subset of <i class="code">source</i>.</dd>
<dt class="code"><a name="Frisket:SubtractFrisket" /><i>destination</i>:SubtractFrisket(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>)</dt>
<dd>Subtracts the data in <i class="code">source</i> (a <a href="#Frisket" class="code">Frisket</a>) from the data already in <i class="code">destination</i>, with the top-left corner at <i class="code">x,y</i>. If <i class="code">source_*</i> are provided, deal with that subset of <i class="code">source</i>.</dd>
<dt class="code"><a name="Frisket:MinFrisket" /><i>destination</i>:MinFrisket(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>)</dt>
<dd>Replace each frixel of <i class="code">destination</i> with the frixels from <i class="code">source</i> (a <a href="#Frisket" class="code">Frisket</a>), but only if the new frixel is more <b>transparent</b> than the old one; with the top-left corner at <i class="code">x,y</i>. If <i class="code">source_*</i> are provided, deal with that subset of <i class="code">source</i>.</dd>
<dt class="code"><a name="Frisket:MaxFrisket" /><i>destination</i>:MaxFrisket(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>)</dt>
<dd>Replace each frixel of <i class="code">destination</i> with the frixels from <i class="code">source</i> (a <a href="#Frisket" class="code">Frisket</a>), but only if the new frixel is more <b>opaque</b> than the old one; with the top-left corner at <i class="code">x,y</i>. If <i class="code">source_*</i> are provided, deal with that subset of <i class="code">source</i>.</dd>
<dt class="code"><a name="Frisket:GetSize" /><i>width</i>,<i>height</i> = <i>frisket</i>:GetSize()</dt>
<dd>Returns the pixel dimensions of this <tt>Frisket</tt></dd>
<dt class="code"><a name="Frisket:SetClipRect" /><i>frisket</i>:SetClipRect(<i>x</i>, <i>y</i>, <i>width</i>, <i>height</i>)</dt>
<dd>Sets the clip rectangle of <i class="code">frisket</i>. No frixels outside the clip rectangle will ever change.</dd>
<dt class="code"><a name="Frisket:GetClipRect" /><i>x</i>, <i>y</i>, <i>width</i>, <i>height</i> = <i>frisket</i>:GetClipRect()</dt>
<dd>Returns the clip rectangle of <i class="code">frisket</i>.</dd>
<dt class="code"><a name="Frisket:GetFrixel" /><i>alpha</i> = <i>frisket</i>:GetFrixel(<i>x</i>, <i>y</i>)</dt>
<dd>Returns the <i class="code">alpha</i> value at a given coordinate. This function is really slow.</dd>
<dt class="code"><a name="Frisket:GetRawFrixel" /><i>frixel</i> = <i>frisket</i>:GetRawFrixel(<i>x</i>, <i>y</i>)</dt>
<dd>Returns the raw <i class="code">frixel</i> value (0-255) at a given coordinate. This function is really slow, but a little faster than <a href="#Frisket:GetFrixel" class="code">GetFrixel</a>.</dd>
</dl>
<h3 class="code"><a name="Drawable" />Drawable</h3>
<p>A <tt>Drawable</tt> is, basically, an image. It normally comes in two flavors, <a href="#Graphic" class="code">Graphic</a> and <a href="#GraphicsDevice" class="code">GraphicsDevice</a>. Both flavors support all of the below code.</p>
<dl>
<dt class="code"><a name="Drawable:GetSize" /><i>width</i>,<i>height</i> = <i>drawable</i>:GetSize()</dt>
<dd>Returns the pixel dimensions of this <tt>Drawable</tt></dd>
<dt class="code"><a name="Drawable:Blit" /><i>destination</i>:Blit(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>[, <i>alpha</i>])</dt>
<dd>Draws <i class="code">source</i> (a <a href="#Drawable" class="code">Drawable</a>) on <i class="code">destination</i>, with the top-left corner at <i class="code">x,y</i>. If <i class="code">source_*</i> are provided, deal with that subset of <i class="code">source</i>. If <i class="code">alpha</i> is specified, draw it with the given level of opacity. (1 is opaque, 0 is fully transparent.)</dd>
<dd>Note: Unlike the corresponding function in SDL, this function handles partially-transparent blitting of an image with an alpha channel.</dd>
<dd>Note 2: It is perfectly reasonable for <i class="code">source</i> to be a <a href="#GraphicsDevice" class="code">GraphicsDevice</a>.</dd>
<dt class="code"><a name="Drawable:BlitFrisket" /><i>destination</i>:BlitFrisket(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>)</dt>
<dd>Draws <i class="code">source</i> (a <a href="#Frisket" class="code">Frisket</a>) on <i class="code">destination</i>, with the top-left corner at <i class="code">x,y</i>. If <i class="code">source_*</i> are provided, deal with that subset of <i class="code">source</i>.</dd>
<dd>This function uses the selected primitive color (see <a href="#Drawable:SetPrimitiveColor" class="code">SetPrimitiveColor</a>). If the primitive color is transparent, <i class="code">source</i>'s data is modulated appropriately.</dd>
<dt class="code"><a name="Drawable:Copy" /><i>destination</i>:Copy(<i>source</i>, [<i>source_x</i>, <i>source_y</i>, <i>source_w</i>, <i>source_h</i>,] <i>x</i>, <i>y</i>)</dt>
<dd>Identical to <a href="#Drawable:Blit" class="code">Blit</a>, but copies data (including alpha channel) without blending. Useful for composing/decomposing sprite sheets.</dd>
<dd>Note: This is the only blitting operation that is permitted on a <a href="#Drawable" class="code">Drawable</a> which has an alpha channel. This is also the only blitting operation that can cause a <a href="#Drawable" class="code">Drawable</a> that previously had no alpha channel to have one, in which event the <a href="#Drawable" class="code">Drawable</a> is now tainted and cannot be blitted on in any other way. This tainting will occur whenever you copy from a <a href="#Drawable" class="code">Drawable</a> that has an alpha channel, regardless of whether you copied any of its transparent pixels!</dd>
<dt class="code"><a name="Drawable:SetPrimitiveColor" /><i>drawable</i>:SetPrimitiveColor(<i>r</i>, <i>g</i>, <i>b</i>[, <i>a</i>])</dt>
<dd>Sets the current "primitive color," which is used by <a href="#Drawable:DrawPoints" class="code">DrawPoints</a>, <a href="#Drawable:DrawLines" class="code">DrawLines</a>, <a href="#Drawable:DrawLineLoop" class="code">DrawLineLoop</a>, <a href="#Drawable:DrawLineStrip" class="code">DrawLineStrip</a>, <a href="#Drawable:DrawTriangles" class="code">DrawTriangles</a>, <a href="#Drawable:DrawTriangleStrip" class="code">DrawTriangleStrip</a>, <a href="#Drawable:DrawTriangleFan" class="code">DrawTriangleFan</a>, <a href="#Drawable:DrawRect" class="code">DrawRect</a>, <a href="#Drawable:DrawBox" class="code">DrawBox</a>, and <a href="#Drawable:BlitFrisket" class="code">BlitFrisket</a>. If <i class="code">a</i> is not provided, full opacity (<tt>1</tt>) is assumed.</dd>
<dt class="code"><a name="Drawable:SetPrimitiveColorPremul" /><i>drawable</i>:SetPrimitiveColorPremul(<i>pr</i>, <i>pg</i>, <i>pb</i>[, <i>a</i>])</dt>
<dd>Like above, but using premultiplied colors. If you don't understand what this means, use <a href="#Drawable:SetPrimitiveColor" class="code">SetPrimitiveColor</a> instead.</dd>
<dd>Note that this will not work right with <a href="#Frisket" class="code">Frisket</a>s.</dd>
<dt class="code"><a name="Drawable:DrawPoints" /><i>destination</i>:DrawPoints(<i>coords</i>, <i>diameter</i>)</dt>
<dd>Draw points <i class="code">diameter</i> in diameter at every coordinate in <i class="code">coords</i> (a CoordArray, see <a href="#CompileCoords" class="code">CompileCoords</a>) using the current primitive color.</dd>
<dd>Note: Points, and all other primitives, fully support alpha in the primitive color.</dd>
<dd>Note 2: Currently, points are rendered as rectangles and lack subpixel precision. In the future, they may be rendered as circles and gain subpixel precision.</dd>
<dt class="code"><a name="Drawable:DrawLines" /><i>destination</i>:DrawLines(<i>coords</i>, <i>indices</i>, <i>width</i>, [<i>height</i>])</dt>
<dd>Each pair of indices in <i class="code">indices</i> (an IndexArray, see <a href="#CompileIndices" class="code">CompileIndices</a>) designates two coordinate pairs in <i class="code">coords</i> (a CoordArray, see <a href="#CompileCoords" class="code">CompileCoords</a>) between which a <i class="code">width</i> (possibly non-integer) pixel wide line should be drawn using the current primitive color. (<i class="code">height</i> should only be specified to handle non-1:1 aspect ratios.)</dd>
<dd>Lines in SubCritical are drawn with subpixel precision, but not antialiased.</dd>
<dd>If you wish to draw only a single line, the following code is more convenient:</dd>
<dd><pre>local _i = SCUtil.CompileIndices{0,1}
function draw_line(destination, width, x1, y1, x2, y2)
  local c = SCUtil.CompileCoords{x1,y1,x2,y2}
  return destination:DrawLines(width, c, _i)
end</pre></dd>
<dd>If you want to draw only straight horizontal or vertical lines, you should use <a href="#Drawable:DrawRect" class="code">DrawRect</a> (or <a href="#Drawable:DrawBox" class="code">DrawBox</a>) instead, since its results are easier to control. (DrawLine might disagree with your expectations on exactly what pixels get filled.)</dd>
<dd>Note: Lines, and all other primitives, fully support alpha in the primitive color.</dd>
<dt class="code"><a name="Drawable:DrawLineStrip" /><i>destination</i>:DrawLineStrip(<i>coords</i>, <i>indices</i>, <i>width</i>, [<i>height</i>])</dt>
<dd>As with DrawLines, but <i class="code">indices</i> are handled differently. The first index does nothing on its own. All indices after it designate a line between themselves and the index before them. (Essentially, <i>indices</i> designates a continuous strip of lines, hence the name.)</dd>
<dt class="code"><a name="Drawable:DrawLineLoop" /><i>destination</i>:DrawLineLoop(<i>coords</i>, <i>indices</i>, <i>width</i>, [<i>height</i>])</dt>
<dd>As with DrawLineStrip, with an additional line between the last and first indices.</dd>
<dt class="code"><a name="Drawable:DrawTriangles" /><i>destination</i>:DrawTriangles(<i>coords</i>, <i>indices</i>)</dt>
<dd>Each triple of indices in <i class="code">indices</i> (an IndexArray, see <a href="#CompileIndices" class="code">CompileIndices</a>) designates three coordinate pairs in <i class="code">coords</i> (a CoordArray, see <a href="#CompileCoords" class="code">CompileCoords</a>) which form a triangle that should be drawn with the current primitive color.</dd>
<dd>Triangles in SubCritical are drawn with subpixel precision, but not antialiased. SubCritical consistently uses a top-left fill convention, so abutting triangles will not have holes or overdraw. SubCritical also does clipping to the clip rectangle of the <span class="code">Drawable</span>, so you gain nothing from doing such clipping yourself.</dd>
<dd>Note: Triangles, and all other primitives, fully support alpha in the primitive color.</dd>
<dt class="code"><a name="Drawable:DrawTriangleStrip" /><i>destination</i>:DrawTriangleStrip(<i>coords</i>, <i>indices</i>)</dt>
<dd>As with DrawTriangles, but <i class="code">indices</i> are handled differently. The first triple designates a triangle, then each index after that designates a new triangle between it and the two indices before it.</dd>
<dt class="code"><a name="Drawable:DrawTriangleFan" /><i>destination</i>:DrawTriangleFan(<i>coords</i>, <i>indices</i>)</dt>
<dd>As with DrawTriangles, but <i class="code">indices</i> are handled differently. The first triple designates a triangle, then each index after that designates a new triangle between it, the index before it, and the first index.</dd>
<dt class="code"><a name="Drawable:DrawRect" /><i>destination</i>:DrawRect(<i>left</i>, <i>top</i>, <i>width</i>, <i>height</i>)</dt>
<dd>Designates a rectangle to be drawn in the primitive color. (This function's interface was changed as of 0b1.)</dd>
<dt class="code"><a name="Drawable:DrawBox" /><i>destination</i>:DrawBox(<i>left</i>, <i>top</i>, <i>width</i>, <i>height</i>) -- thickness of 1
<i>destination</i>:DrawBox(<i>left</i>, <i>top</i>, <i>width</i>, <i>height</i>, <i>thickness</i>)</dt>
<dd>Designates a rectangle to be outlined in the primitive color at the given thickness. The lines will fall entirely <b>inside</b> the given rectangle.</dd>
<dt class="code"><a name="Drawable:SetClipRect" /><i>drawable</i>:SetClipRect(<i>x</i>, <i>y</i>, <i>width</i>, <i>height</i>)</dt>
<dd>Sets the clip rectangle of <i class="code">drawable</i>. No pixels outside the clip rectangle will ever change.</dd>
<dt class="code"><a name="Drawable:GetClipRect" /><i>x</i>, <i>y</i>, <i>width</i>, <i>height</i> = <i>drawable</i>:GetClipRect()</dt>
<dd>Returns the clip rectangle of <i class="code">drawable</i>.</dd>
<dt class="code"><a name="Drawable:TakeSnapshot" /><i>graphic</i> = <i>drawable</i>:TakeSnapshot()</dt>
<dd>A convenience function that returns a <a href="#Graphic" class="code">Graphic</a> containing a copy of the current image data in <i class="code">drawable</i>. No drawing state is copied, only image data.</dd>
<dt class="code"><a name="Drawable:GetPixel" /><i>red</i>, <i>green</i>, <i>blue</i>, <i>alpha</i> = <i>drawable</i>:GetPixel(<i>x</i>, <i>y</i>)</dt>
<dd>Returns the color values at a given coordinate in a linear colorspace. This function is really slow.</dd>
<dt class="code"><a name="Drawable:GetRawPixel" /><i>pixel</i> = <i>drawable</i>:GetRawPixel(<i>x</i>, <i>y</i>)</dt>
<dd>Returns the raw <i class="code">pixel</i> value (0-4294967295 in ARGB8888 format) at a given coordinate. This function is really slow, but a little faster than <a href="#Drawable:GetPixel" class="code">GetPixel</a> or <a href="#Drawable:GetSRGBPixel" class="code">GetSRGBPixel</a>.</dd>
<dt class="code"><a name="Drawable:GetRawAlpha" /><i>alpha</i> = <i>drawable</i>:GetRawAlpha(<i>x</i>, <i>y</i>)</dt>
<dd>Returns the raw <i class="code">alpha</i> value (0-255) at a given coordinate. This function is really slow, but a little faster than <a href="#Drawable:GetPixel" class="code">GetPixel</a> or <a href="#Drawable:GetSRGBPixel" class="code">GetSRGBPixel</a>.</dd>
<dt class="code"><a name="Drawable:GetRawPixelNoAlpha" /><i>pixel</i> = <i>drawable</i>:GetRawPixelNoAlpha(<i>x</i>, <i>y</i>)</dt>
<dd>Returns the raw <i class="code">pixel</i> value (0-16777215 in RGB888 format) with the alpha channel removed at a given coordinate. This function is really slow, but a little faster than <a href="#Drawable:GetPixel" class="code">GetPixel</a> or <a href="#Drawable:GetSRGBPixel" class="code">GetSRGBPixel</a>.</dd>
<dt class="code"><a name="Drawable:GetSRGBPixel" /><i>red</i>, <i>green</i>, <i>blue</i>, <i>alpha</i> = <i>drawable</i>:GetSRGBPixel(<i>x</i>, <i>y</i>)</dt>
<dd>Returns the raw color values at a given coordinate in the sRGB colorspace. This function is really slow, but a little faster than <a href="#Drawable:GetPixel" class="code">GetPixel</a>. sRGB color values are not suitable for direct use by other SubCritical functions accepting colors as parameters; if you intend to use these values elsewhere in SubCritical, you probably want <a href="#Drawable:GetPixel" class="code">GetPixel</a> instead.</dd>
</dl>
<h3 class="code"><a name="Graphic" />Graphic : <a href="#Drawable">Drawable</a></h3>
<p>A <tt>Graphic</tt> is a <a href="#Drawable" class="code">Drawable</a> whose lot in life is to eventually be blitted to other <a href="#Drawable" class="code">Drawable</a>s. See <a href="#Drawable:Blit" class="code">Drawable:Blit</a>.</p>
<dl>
<dt class="code"><i>graphic</i> = SubCritical.Construct("Graphic", <i>width</i>, <i>height</i>)</dt>
<dd>Creates a new graphic with no alpha channel (but undefined data).</dd>
<dt class="code"><a name="Graphic:OptimizeFor" /><i>graphic</i>:OptimizeFor(<i>drawable</i>)</dt>
<dd>If necessary, converts <i class="code">graphic</i>'s internal pixel format for fast blitting to <i class="code">drawable</i>. This is normally done automatically, but you can do the work ahead of time with this function if you so choose. (It's not worth it.)</dd>
</dl>
<h3 class="code"><a name="GraphicsDevice" />GraphicsDevice : <a href="#Drawable">Drawable</a></h3>
<p>A <tt>GraphicsDevice</tt> is a mild-mannered <a href="#Drawable" class="code">Drawable</a> by day and what the user actually sees by night.</p>
<dl>
<dt class="code"><i>device</i> = SubCritical.Construct("GraphicsDevice", <i>width</i>, <i>height</i>)
<i>device</i> = SubCritical.Construct("GraphicsDevice", <i>width</i>, <i>height</i>, {[windowed=<i>is_windowed</i>,] [title=<i>window_title</i>,] [extensions]})</dt>
<dd>Tries to construct and initialize a new <tt>GraphicsDevice</tt> of the given <i class="code">width</i> and <i class="code">height</i>. If <tt>windowed</tt>, try to create a windowed context instead of a fullscreen one. If <tt>windowed</tt> is <b>not</b> specified, and <i class="code">width</i> and <i class="code">height</i> are zero, pick a reasonable size (such as the user's current desktop resolution). If the exact resolution cannot be achieved, use black borders and the smallest resolution large enough to fit all the requested pixels. If <tt>title</tt> is specified, use <i class="code">window_title</i> instead of the device-specific default title.</dd>
<dd>A list of known extensions:
<dl>
<dt class="code">true_width, true_height = <i>some_width</i>, <i>some_height</i></dt>
<dd>If specified, the GraphicsDevice will simulate a framebuffer of these dimensions, scaling up or down as needed for display. A retro-style game might set a true_width of 256 and a true_height of 224 for a Super Nintendo screen, for instance.</dd>
<dd>All GraphicsDevice implementations that ship with SubCritical support this extension.</dd>
<dt class="code">keep_aspect = true</dt>
<dd>If true, and a <i class="code">true_width</i> and/or <i class="code">true_height</i> are specified, black borders may be added to avoid "squishing" of the video. You probably want to specify this, especially if the display <i class="code">width</i> and <i class="code">height</i> are zero.</dd>
<dd>All GraphicsDevice implementations that ship with SubCritical support this extension.</dd>
<dt class="code">smooth_filter = true</dt>
<dd>If true, and a <i class="code">true_width</i> and/or <i class="code">true_height</i> are specified, try to use a smoother filter for magnification. If you are not dealing with a display <i class="code">width</i> and <i class="code">height</i> that are an integer multiple of the <i class="code">true_width</i> and <i class="code">true_height</i>, you probably want this.</dd>
<dd>Under some circumstances, even with drivers that normally support it, <tt>smooth_filter</tt> can be ignored. Whether this means a "blocky" filter will always be used is driver-dependent. In summary, even in the presence of a specific value for this option, you never know exactly what filter is being used.</dd>
<dt class="code">borderless = true</dt>
<dd>If you are requesting a windowed <tt>GraphicsDevice</tt>, center the window on the screen and do not draw window decorations for it. This is intended for transient splash screens, and should not be used for anything else.</dd>
<dd>All GraphicsDevice implementations that ship with SubCritical support this extension.</dd>
</dl>
<dd>Attempting to construct a new <tt>GraphicsDevice</tt> renders all previous ones unusable, even if the attempt fails. As of SubCritical version 0c1, you do not need to ensure that any previous ones are garbage collected before constructing a new one; however, be aware that any method calls on a previous <tt>GraphicsDevice</tt> will definitely crash.</dd>
</dd>
<dt class="code"><a name="GraphicsDevice:Update" /><i>device</i>:Update()
<i>device</i>:Update(<i>x</i>, <i>y</i>, <i>width</i>, <i>height</i>)</dt>
<dd>Copies the pixels inside the given rectangle (or, if none is specified, all pixels) to the screen, where the user can get at them. A common mistake is to forget to call this after you're finished blitting.</dd>
<dd>Note: A larger region of the screen may be updated than you specify here. Some drivers always update the entire screen.</dd>
<dd>Note 2: If your state changes in response to user events, don't just redraw and call <tt>Update</tt>() every time; handle events until no more are available, <i>then</i> call it. Otherwise, your code may go into slow-motion if the user is faster than their computer.</dd>
<dt class="code"><a name="GraphicsDevice:GetMousePos" /><i>x</i>,<i>y</i> = <i>device</i>:GetMousePos()</dt>
<dd>Returns the current mouse position, in pixels.</dd>
<dd>This should only be used if you need to know where the mouse is <b>right now</b> and someone else was handling events immediately prior.</dd>
<dt class="code"><a name="GraphicsDevice:GetEvent" /><i>event</i> = <i>device</i>:GetEvent{[wait=<i>should_wait</i>,] [relmouse=<i>should_relmouse</i>,] [textok=<i>is_textok</i>,]}</dt>
<dd>If any events are available, return the next one as a table. If <tt>wait</tt> is true, don't return until an event becomes available. If <tt>relmouse</tt> is true, return relative mouse motion directly instead of keeping track of an absolute mouse position. If <tt>textok</tt> is true, process the user's keystrokes and give us every character they type.</dd>
<dd>The returned table contains a "type" member denoting its type. Its structure is complicated. An example game included in this directory (<tt>printevents.scg</tt>) will print all received events, you can use it to determine the form of the specific events you're looking for.</dd>
<dt class="code"><a name="GraphicsDevice:GetScreenModes" /><i>modes</i>, <i>desktop_mode</i> = <i>device</i>:GetScreenModes()</dt>
<dd>This function returns two values:<dl>
<dt class="code"><i>modes</i></dt>
<dd>This will be an array containing one or more tables like {<i class="code">width</i>, <i class="code">height</i>}; one for every fullscreen mode this driver supports, if this information is available. This may also be <tt>nil</tt>, if the driver does not have a master list of modes.</dd>
<dd>Note: You may also ask for modes outside this list; the driver will pick the smallest available mode that fits your requested size, and fill the extra space with black borders.</dd>
<dt class="code"><i>desktop_mode</i></dt>
<dd>This will be a table like {<i class="code">width</i>, <i class="code">height</i>} containing the user's desktop resolution, if this information is available, or <tt>nil</tt> otherwise. This will likely also be the monitor's native resolution.</dd>
</dl></dd>
<dd>If your game wants to get this information without going into fullscreen, you might do so by having a windowed, <tt>borderless</tt> "splash screen" at a small, known resolution, and calling <tt>ListModes</tt> on that <tt>GraphicsDevice</tt> before going fullscreen.</dd>
<dt class="code"><a name="GraphicsDevice:SetCursor" /><i>device</i>:SetCursor(nil)
<i>device</i>:SetCursor(<i>graphic</i>[, <i>hot_x</i>, <i>hot_y</i>])</dt>
<dd>Display the given <a href="#Graphic" class="code">Graphic</a> at the position of the cursor. If <i class="code">hot_x</i>/<i class="code">y</i> are given, they are the position of the cursor "hot pixel;" it is this pixel which will be centered on the cursor position. If either are unspecified, 0 is used.</dd>
<dd>Setting the cursor to nil disables display of the cursor. (This is the default state.)</dd>
<dd>Under most circumstances, the cursor will only be updated when <a href="#GraphicsDevice:Update" class="code">Update</a> is called. If you want the cursor to be smoothly updated even when you're not doing any other drawing, try calling <tt><i>device</i>:Update(0,0,0,0)</tt> whenever you receive a <tt>"mousemove"</tt>, <tt>"mousedown"</tt>, or <tt>"mouseup"</tt> event.</dd>
</dl>
<h3 class="code"><a name="GraphicLoader" />GraphicLoader</h3>
<p>An instance of <tt>GraphicLoader</tt> is poised to read from image files and give you nice, juicy <a href="#Graphic">Graphic</a>s to use in your game.</p>
<p>You cannot instantiate a <tt>GraphicLoader</tt> directly, and should not try to <a class="code" href="subcritical.html#Construct">Construct</a> one, since you won't know what format(s) the returned GraphicLoader can load. Instead, you should <a class="code" href="subcritical.html#Construct">Construct</a> a specific loader (such as <a class="code" href="png.html#PNGLoader">PNGLoader</a>, <a class="code" href="jpeg.html#JPEGLoader">JPEGLoader</a>, or <a class="code" href="gif.html#GIFLoader">GIFLoader</a>) and use that.</p>
<dl>
<dt class="code"><a name="GraphicLoader:Load" /><i>graphic</i>,<i>error</i> = <i>loader</i>:Load(<i>path</i>)
<i>graphic</i>,<i>error</i> = assert(<i>loader</i>:Load(<i>path</i>))</dt>
<dd>Tries to load the graphic located at <i class="code">path</i> (see <a class="code" href="subcritical.html#ConstructPath">SCPath</a>) in a format this GraphicLoader understands. If the graphic could not be loaded, returns <tt>nil</tt> and an <i class="code">error</i> message. The easiest way to handle this error is to assert it (as shown above).</dd>
</dl>
<h3 class="code"><a name="GraphicDumper" />GraphicDumper</h3>
<p>An instance of <tt>GraphicDumper</tt> is poised to save the contents of your <a href="#Drawable">Drawable</a>s in some wild new image format.</p>
<p>You cannot instantiate a <tt>GraphicDumper</tt> directly, and should not try to <a href="subcritical.html#Construct">Construct</a> one, since you won't know what format the returned GraphicDumper will save in. Instead, you should <a href="subcritical.html#Construct">Construct</a> a specific dumper (such as <a href="png.html#PNGDumper">PNGDumper</a>) and use that.</p>
<dl>
<dt class="code">function <i>func</i>(<i>value</i>, data) ... end
<a name="GraphicDumper:Dump" /><i>dumper</i>:Dump(<i>image</i>, <i>value</i>, <i>func</i>)</dt>
<dd><i class="code">image</i> is any <a href="#Drawable" class="code">Drawable</a>, <i class="code">value</i> is anything at all, and <i class="code">func</i> is a function that will be called like <tt><i>func</i>(<i>value</i>, <i>data</i>)</tt> where <i>data</i> is data to be written to the file. <i class="code">func</i> must return <tt>true</tt> (or some other true value) if the write succeeded.</dd>
<dd>It is an amazing coincidence that it just so happens that this is how <tt>file:write</tt> behaves. For some Lua file, then, one could <tt><i>dumper</i>:Dump(<i>image</i>, <i>file</i>, <i>file</i>.write)</tt>. Total coincidence, of course.</dd>
</dl>
<h2>Utility functions</h2>
<dl>
<dt class="code"><a name="CompileCoords" /><i>coords</i> = SCUtil.CompileCoords(<i>table</i>)</dt>
<dd>Returns a <tt>CoordArray</tt> suitable for passing to many of <a href="#Drawable" class="code">Drawable</a>'s drawing functions. <i class="code">table</i> should be an array directly containing coordinate pairs in the form of <tt>number</tt>s, and in particular must <b>not</b> be an array of <tt>table</tt>s.</dd>
<dt class="code"><a name="CompileIndices" /><i>indices</i> = SCUtil.CompileIndices(<i>table</i>)</dt>
<dd>Returns an <tt>IndexArray</tt> suitable for passing to many of <a href="#Drawable" class="code">Drawable</a>'s drawing functions. <i class="code">table</i> should be an array directly containing 0-based indices in the form of <tt>number</tt>s.</dd>
<dt class="code"><a name="CullTriangles" /><i>new_indices</i> = SCUtil.CullTriangles<i>CW</i>(<i>coords</i>, <i>indices</i>)
<i>new_indices</i> = SCUtil.CullTriangles<i>CCW</i>(<i>coords</i>, <i>indices</i>)</dt>
<dd>Returns an <tt>IndexArray</tt> containing only those triangles described by <i class="code">coords</i> and <i class="code">indices</i> that wind in the specified direction (clockwise for <tt>CW</tt> and counter-clockwise for <tt>CCW</tt>).</dd>
</dl>
<p><a href="index.html">Back to index</a></p>
</body>
</html>
